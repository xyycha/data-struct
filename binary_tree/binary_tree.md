1. 二叉树定义
    - a. 每个节点都不能有多于两个的儿子
    
2. 二叉树的属性
    - a. 深度：从根到该节点的唯一路径的长度
    - b. 高度: 从该节点到所有叶子节点的最大路径长度
    - c. 树的高度: 从根到叶子节点的最大路径长度

3. 二叉树性质  数据结构和算法的习题
    - a. 有 n个节点的二叉树，一定有 n+1 个空指针， 一定有 n-1个子节点
        - n 个节点，必有一个是根节点，其余都是 子节点 所以 n-1 个子节点
        - 每个子节点都会有一个指针由父节点指向自己，一共 n-1 个非空指针；n个节点一共 2n 个节点，所以空指针个数 n+1
    - b. 非空二叉树叶子个数 等于 满节点个数 + 1
        - 递归推导 每添加一个 满节点，会引进新的一片树叶，也就是叶子数 + 1  f(n+1) = f(n) + 1  f(0) = 1  f(n) = n + 1
    - c. 高度为 H 的二叉树中，节点的最大个数是 2^(H+1) - 1
        - 同样高度的二叉树，节点最多的是满二叉树 h层的节点个数为 2^h
        - 节点个数为 s = 1 + 2 + 4 + ... + 2^H
        - 直接使用 等比数列求和公式计算 a1*q*(1-q^n)/(1-q)
        - 或者 1 + s = 1 + (1 + 2 + 4 + ... + 2^H) = 2 + 2 + 4 + ... + 2^H = 2^(H+1)  s = 2^(H+1)-1
    - d. 设二叉树有树叶l1, l2, ... , lm, 各树叶的深度分别是d1, d2, ... , dm. s = 2^(-d1) + 2^(-d2) + ... + 2^(-dm) <= 1
        - 等号成立的前提：非叶子节点 都必须是 满节点(拥有两个子节点)
        - 小于等于成立的原因: 如果不满足上面的条件，就会少叶子，少叶子s的累加值就会减小
        - 等号成立证明 
            - 设树的高度为H, 某个叶子节点的深度为h.
            - 2^(-h) = 2^(H-h) * 2^(-H)  相当于以该节点为根节点展成满二叉树 叶子数 * 2^(-H) 
            - 将 s 的每一项展开记为 每个叶子节点都会延伸到深度为H的一层  所有的叶子数的和为 M
            - s 的计算 M * 2^(-H) 深度为H的叶子数最大值为 2^H 所以s的最大值就是1 仅当展开的树是 满二叉树时，所以原树 非叶子节点都必须是 满节点
            
4. 二叉树遍历（按照本节点被访问的先后）见 binary_tree_traversal.py
    - a. 前序遍历（本节点，左子节点，右子节点) 
    - b. 中序遍历（左子节点， 本节点， 右子节点）
    - c. 后续遍历（左子节点， 右子节点，本节点)
    
5. 构建二叉树 核心就是找到父节点，左子树节点， 右子树节点，然后递归 见 create_binary_tree_by_traversal.py
    - a. 由前序 中序 构建二叉树
    - b. 由后序 中序 构建二叉树
    - c. 前序 后序 搞不出来二叉树 区分不出来左右子树节点
    
6. 二叉树测试用例 ![完全二叉树示例](http://image.sprinkle.top/image/tree/complete_binary_tree.jpeg)